{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE InstanceSigs #-}

module Xag.Graph
  ( Node (..),
    Graph (..),
    cover,
    freeVariables,
    nodeRefs,
    -- normalize,
    outputs,
    valid,
  )
where

import qualified Data.IntSet as IntSet
import GHC.Float (sqrtFloat)
import GHC.Generics (Generic)
import qualified Test.QuickCheck as QC

-- The Graph is a list of Node; each node has a nodeId, uniquely identifying it.
-- Nodes are ordered by increasing nodeId, and the graph should be acyclic, with
-- each Node referring only to prior XagNodes via its inputs. References to
-- nodeIds not in the list are free variables.

-- Note that although the Const node can take value True or False, only True is
-- useful in analysis -- False inputs to Xor can be trivially pruned, and False
-- inputs to And mean the And can be trivially converted to a Const False.

data Node
  = Const {nodeId :: !Int, value :: !Bool}
  | Not {nodeId :: !Int, xIn :: !Int}
  | Xor {nodeId :: !Int, xIn :: !Int, yIn :: !Int}
  | And {nodeId :: !Int, xIn :: !Int, yIn :: !Int}
  deriving (Eq, Generic, Ord, Read, Show)

newtype Graph = Graph [Node] deriving (Eq, Generic, Ord, Read, Show)

-- compute the set of free variables used by this graph
freeVariables :: Graph -> IntSet.IntSet
freeVariables (Graph allNodes) = freeVariablesRev (reverse allNodes) IntSet.empty
  where
    freeVariablesRev [] freeSoFar = freeSoFar
    freeVariablesRev (node : nodes) freeSoFar =
      IntSet.delete
        (nodeId node)
        (freeVariablesRev nodes (IntSet.union (nodeRefs node) freeSoFar))

-- compute the list of outputs possibly generated by this graph
outputs :: Graph -> IntSet.IntSet
outputs (Graph nodes) = IntSet.fromList (map nodeId nodes)

-- countAnd :: Graph -> Int
-- countAnd (Graph nodes) = foldr (\node -> case And _ _ -> 1; _ -> 0) 0 nodes

-- countAndInputs :: Graph -> Int
-- countAndInputs (Graph nodes) = foldr (\node -> case And _ ins -> length ins; _ -> 0) 0 nodes

-- compute a subset of the graph producing the given outputs
cover :: IntSet.IntSet -> Graph -> Graph
cover initialIds (Graph allNodes) = Graph $ reverse (coverRev initialIds (reverse allNodes))
  where
    coverRev _ [] = []
    coverRev coverIds (node : nodes) =
      if IntSet.member (nodeId node) coverIds
        then node : coverRev (IntSet.union coverIds (nodeRefs node)) nodes
        else coverRev coverIds nodes

nodeRefs :: Node -> IntSet.IntSet
nodeRefs (Not _ x) = IntSet.singleton x
nodeRefs (Xor _ x y) = IntSet.fromList [x, y]
nodeRefs (And _ x y) = IntSet.fromList [x, y]
nodeRefs _ = IntSet.empty

-- Do the most trivial operations required to reduce the complexity of an XAG
-- normalize :: Graph -> Graph
-- normalize (Graph allNodes) =
--   case firstTrueConst allNodes of
--     Nothing -> Graph $ filterNodes IntSet.empty allNodes
--       where
--         -- If no constant true is present in the graph, there must also not be
--         -- any trivial true outputs. This arises because you can't get a true
--         -- output from an XOR or AND gate without a true input, therefore any
--         -- true outputs must be nontrivial. This is a convenient fact for us
--         -- in that the constant will always be there if we need it, but then
--         -- we still need to special-case the reduction when that happens.
--         filterNodes :: IntSet.IntSet -> [Node] -> [Node]
--         filterNodes _ [] = []
--         -- Add constant false to the trivial set
--         filterNodes trivialFalse (Const nid False : nodes) =
--           filterNodes (IntSet.insert nid trivialFalse) nodes
--         filterNodes _ (Const _ True : _) = undefined
--         -- Xor:
--         -- Remove trivial false inputs;
--         -- Remove inputs that appear an even number of times;
--         -- Remap trivial true inputs to the first constant true found.
--         filterNodes trivialFalse (Xor nid x y : nodes) =
--           Xor nid gatheredInputs : filterNodes trivialFalse nodes
--           where
--             gatheredInputs = IntSet.foldr xorGather IntSet.empty (IntSet.fromList [x, y])

--             xorGather inp gathered
--               -- Ignore trivial false inputs
--               | IntSet.member inp trivialFalse = gathered
--               -- Track whether inputs have canceled themselves out
--               | otherwise = invertMembership inp gathered

--             invertMembership n s
--               | IntSet.member n s = IntSet.delete n s
--               | otherwise = IntSet.insert n s

--         -- And:
--         -- If any input is trivial false, add this to the trivial false set;
--         -- Otherwise include it with repeated inputs removed.
--         filterNodes trivialFalse (And nid andInputs : nodes) =
--           if not (IntSet.disjoint trivialFalse andInputs)
--             then filterNodes (IntSet.insert nid trivialFalse) nodes
--             else And nid andInputs : filterNodes trivialFalse nodes
--     Just trueId -> Graph $ Const trueId True : filterNodes IntSet.empty IntSet.empty allNodes
--       where
--         filterNodes :: IntSet.IntSet -> IntSet.IntSet -> [Node] -> [Node]
--         filterNodes _ _ [] = []
--         -- Add constant true/false to the trivial set
--         filterNodes trivialFalse trivialTrue (Const nid False : nodes) =
--           filterNodes (IntSet.insert nid trivialFalse) trivialTrue nodes
--         filterNodes trivialFalse trivialTrue (Const nid True : nodes) =
--           filterNodes trivialFalse (IntSet.insert nid trivialTrue) nodes
--         -- Xor:
--         -- Remove trivial false inputs;
--         -- Remove inputs that appear an even number of times;
--         -- Remap trivial true inputs to the first constant true found.
--         filterNodes trivialFalse trivialTrue (Xor nid x y : nodes) =
--           Xor nid gatheredInputs : filterNodes trivialFalse trivialTrue nodes
--           where
--             gatheredInputs = IntSet.foldr xorGather IntSet.empty (IntSet.fromList [x, y])

--             xorGather inp gathered
--               -- Ignore trivial false inputs
--               | IntSet.member inp trivialFalse = gathered
--               -- Map trivial true to the one true ID (canceling it out if needed)
--               | IntSet.member inp trivialTrue = invertMembership trueId gathered
--               | otherwise = IntSet.insert inp gathered

--             invertMembership n s
--               | IntSet.member n s = IntSet.delete n s
--               | otherwise = IntSet.insert n s

--         -- And:
--         -- If any input is trivial false, add it to the trivial false set;
--         -- Remove any trivial true inputs;
--         --   If no inputs remain, add it to the trivial true set;
--         --   Otherwise include it with nontrivial inputs only.
--         filterNodes trivialFalse trivialTrue (And nid x y : nodes)
--           | not (IntSet.disjoint (IntSet.fromList [x, y]) trivialFalse) =
--               filterNodes (IntSet.insert nid trivialFalse) trivialTrue nodes
--           | IntSet.isSubsetOf (IntSet.fromList [x, y]) trivialTrue =
--               filterNodes (IntSet.insert nid trivialFalse) trivialTrue nodes
--           | otherwise =
--               And nid (IntSet.difference (IntSet.fromList [x, y]) trivialTrue)
--                 : filterNodes trivialFalse trivialTrue nodes
--   where
--     firstTrueConst [] = Nothing
--     firstTrueConst (Const nid True : _) = Just nid
--     firstTrueConst (_ : nodes) = firstTrueConst nodes

-- checks properties of nodeId order and uniqueness, and acyclic refs
valid :: Graph -> Bool
valid (Graph ns) = validNodes 0 ns
  where
    validNodes _ [] = True
    validNodes nextId (node : nodes) =
      validNode nextId node && validNodes (nodeId node + 1) nodes
    validNode nextId (Const n _) = n >= nextId
    validNode nextId (Not n x) = (n >= nextId) && validInput n x
    validNode nextId (Xor n x y) = (n >= nextId) && validInput n x && validInput n y
    validNode nextId (And n x y) = (n >= nextId) && validInput n x && validInput n y
    -- validNode nextId (Var n) = n >= nextId

    validInput :: Int -> Int -> Bool
    validInput n x = (x >= 0) && (x < n)

-- eval :: Graph a -> (b -> b -> b) -> (b -> b -> b) -> (a -> b) -> b
-- eval (Xor x y) xorF andF litF = xorF (eval x xorF andF litF) (eval y xorF andF litF)
-- eval (And x y) xorF andF litF = andF (eval x xorF andF litF) (eval y xorF andF litF)
-- eval (Lit v) _ _ litF = litF v

-- andCost :: (Num b) => Graph a -> b
-- andCost g = eval g (+) (\x y -> x + y + 1) (const 0)

-- (Xor x y)
-- (And x y)1
-- (Lit v)

-- The Arbitrary makes a valid, arbitrary Graph with a gap for free variables,
-- and then a number of Not, Xor, and And nodes to fill the list to the
-- arbitrary size. Inputs are weighted to prefer earlier nodes, so as to bias
-- towards shallower graphs.
instance QC.Arbitrary Graph where
  arbitrary :: QC.Gen Graph
  arbitrary = do
    nNodes <- QC.getSize
    let nVars = (ceiling . sqrtFloat . fromIntegral) nNodes + 1
    nodes <- mapM genNode [nVars .. nVars + nNodes - 1]
    return $ Graph nodes
    where
      genNode n = do
        QC.frequency [(1, genConstNode n), (10, genNotNode n), (20, genXANode n)]

      genConstNode n = do
        val <- QC.oneof [return True, return False]
        return $ Const n val

      genNotNode n = do
        xInput <- genIndex n
        return $ Not n xInput

      genXANode n = QC.oneof [genBinary n Xor, genBinary n And]
        where
          genBinary :: Int -> (Int -> Int -> Int -> Node) -> QC.Gen Node
          genBinary n xa = do
            xInput <- genIndex n
            yInput <- genIndex n
            return $ xa n xInput yInput

      genIndex 0 = undefined
      genIndex n = do
        unbiased <- QC.choose (0, n * n - 1)
        return $ unbiased `div` n
